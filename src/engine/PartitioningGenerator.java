package engine;

import java.util.ArrayList;
import java.util.List;

import org.openscience.cdk.group.Graph;

import test_group.TestDiscretePartitionRefiner;




/**
 * Generate graphs (currently) from numbers that represent 
 * 
 * @author maclean
 *
 */
public class PartitioningGenerator {

    /**
     * The key method for this class - generate all the structures that have
     * <code>totalValence</code> total valence, and <code>numberOfAtoms</code>
     * atoms and with a maximum valence of <code>maxValence</code>.
     * 
     * So, for a constitutional formula like 'C4H6', the total valence is
     * ((number of carbons) * (carbon valence)) - (number of hydrogens) =
     * (4 * 4) - 6 = 10. There are 4 carbon atoms, so the call would be:
     * 
     *   PartitioningGenerator.generate(10, 4, 4);
     *   
     * to get all the C4H6s.
     * 
     * @param totalValence
     * @param numberOfAtoms
     * @param maxValence
     * @return
     */
    public static List<Graph> generate(
            int totalValence, int numberOfAtoms, int maxValence) {

        List<Graph> graphs = new ArrayList<Graph>();
        IntegerPartition[] partitions = PartitionCalculator.partition(
                    totalValence, numberOfAtoms);
        
        for (IntegerPartition partition : partitions) {
            /* This line is necessary because the partition calculator will
             * make partitions like 10 = [7, 1, 1, 1] and '7' is too high a
             * valence
             */
            if (partition.getPart(0) > maxValence) continue;
            PartitioningGenerator.generateForPartition(partition, graphs);
        }

        return graphs;
    }

    /**
     * Add to the list of graphs all the graphs generated by this partition.
     * 
     * @param p the partition to make graphs from
     * @param graphs the list of graphs to add to
     */
    public static void generateForPartition(IntegerPartition p, List<Graph> graphs) {
        PartitioningGenerator.backtrack(p, graphs, 0, new PartialSolution(p.size()));
    }
    
    /**
     * For a particular partition, make all the structures that correspond to
     * it.
     * 
     * @param p
     * @param graphs
     * @param partIndex
     * @param solution
     */
    private static void backtrack(
            IntegerPartition p, List<Graph> graphs, int partIndex, PartialSolution solution) {
        
        if (PartitioningGenerator.isOkay(solution, p) ||
                partIndex >= p.size()) {
//            PartitioningGenerator.backtrackGraph(
//                    solution, new Graph("C", solution.size()), 0, graphs);
            PartitioningGenerator.backtrackGraph(
                    solution, new Graph(), 0, graphs);
        } else {
            int part = p.getPart(partIndex);
            for (int[] subPartition : 
                PartitioningGenerator.getPossibleNextSubPartitions(part)) {
                PartitioningGenerator.backtrack(
                        p, 
                        graphs, 
                        partIndex + 1, 
                        solution.add(subPartition));
            }
        }
    }
    
    /**
     * Potentially check the solution for viability - at the moment, just
     * ensure that it is long enough.
     * 
     * @param solution
     * @param partition
     * @return
     */
    private static boolean isOkay(PartialSolution solution, IntegerPartition partition) {
        return solution.size() == partition.size();
    }

    /**
     * Simple method to get all the sub-partitions for a particular part.
     * 
     * @param part
     * @return
     */
    private static List<int[]> getPossibleNextSubPartitions(int part) {
        List<int[]> subPartitions = new ArrayList<int[]>();
        for (int[] subPartition : IntegerPartition.basicPartitions[part]) {
            subPartitions.add(subPartition);
        }
        return subPartitions;
    }
    
    private static boolean isCanonical(Graph graph) {
        return new TestDiscretePartitionRefiner().isCanonical(graph);
    }

    /**
     * For a 'solution' (a list of sub-partitions) produce all graphs that
     * are consistent with these sub-partitions. It does this by:
     * 
     *  1) For each sub-part (half-bond) on one atom do
     *  2) Try to find all matching sub-parts (with solution.indexOf)
     *  3) Add these two half-bonds as an arc in the graph
     *  4) Remove the half-bonds from a copy of the solution, and backtrack
     *  
     * in this way, all graphs are produced, but they will be redundant.
     * 
     * @param solution
     * @param graph
     * @param i
     * @param gs
     */
    private static void backtrackGraph(
            PartialSolution solution, Graph graph, int i, List<Graph> gs) {
        if (i == solution.size() - 1) {
//            if (graph.edgesInOrder() && graph.isConnected()) {
            if (graph.isConnected() && PartitioningGenerator.isCanonical(graph)) {
                gs.add(graph);
            }
        } else {
            if (solution.hasSubPartsAt(i)) {
                int lastSubPart = -1;
                for (int x = 0; x < solution.sizeAt(i); x++) {
                    
                    // avoid duplicating graphs
                    if (solution.subPartAt(i, x) == lastSubPart) {
                        continue;
                    }
                    
                    int subPart = solution.subPartAt(i, x);
                    for (int j = i + 1; j < solution.size(); j++) {
                        
                        // check for existing bonds between these atoms
                        if (graph.isConnected(i, j)) continue;
                        
                        // try to find a matching half-bond
                        int k = solution.indexOf(subPart, j);
                        if (k == -1) continue;
                        
                        Graph graphCopy = new Graph(graph);
                        graphCopy.makeEdge(i, j, subPart);
                        
                        PartialSolution solutionCopy = new PartialSolution(solution);
                        solutionCopy.remove(i, x);
                        solutionCopy.remove(j, k);
                        
                        backtrackGraph(solutionCopy, graphCopy, i, gs);
                    }
                    lastSubPart = subPart;
                }
            } else {
                // no more half-bonds to connect at this atom 
                backtrackGraph(
                        new PartialSolution(solution), new Graph(graph), i + 1, gs);
            }
        }
    }

    public static void main(String[] args) {
        int valence = Integer.parseInt(args[0]);
        int numberOfAtoms = Integer.parseInt(args[1]);
        int maxValence = Integer.parseInt(args[2]);
        for (Graph g : PartitioningGenerator.generate(
                valence, numberOfAtoms, maxValence)) {
            System.out.println(g);
        }
    }
}
